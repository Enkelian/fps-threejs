<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Native three.js with Physics</title>
<!--    <link rel="stylesheet" href="/css/examples.css?ver=1.0.0" />-->
    <script src="./lib/three.js"></script>
    <script src="./lib/enable3d.ammoPhysics.0.20.0.min.js"></script>
    <script src="./lib/OrbitControls.js"></script>
    <script src="./lib/FBXLoader.js"></script>
    <script src="./lib/inflate.min.js"></script>

  </head>

  <body>
    <script type="module">

      const { AmmoPhysics, PhysicsLoader } = ENABLE3D



      const MainScene = () => {


        // scene
        const scene = new THREE.Scene()
        scene.background = new THREE.Color(0xf0f0f0)

        // camera
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(10, 10, 20)

        // renderer
        const renderer = new THREE.WebGLRenderer()
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)

        // dpr
        const DPR = window.devicePixelRatio
        renderer.setPixelRatio(Math.min(2, DPR))



        // orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement)

        // light
        scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 1))
        scene.add(new THREE.AmbientLight(0x666666))
        const light = new THREE.DirectionalLight(0xdfebff, 1)
        light.position.set(50, 200, 100)
        light.position.multiplyScalar(1.3)


        const physics = new AmmoPhysics(scene)

        physics.debug.enable(true)
        // extract the object factory from physics
        // the factory will make/add object without physics

        const { factory } = physics
        // blue box
        // physics.add.box({ x: 0.05, y: 10 }, { lambert: { color: 0x2194ce } })

        const pistol = new THREE.FBXLoader();
        pistol.load( './guns/FBX/Pistol.fbx', object => {
          object.scale.setScalar(0.01);
          object.position.y += 5;
          object.traverse( function ( child ) {
            if ( child.isMesh ) {
              child.material.wireframe = true;
            }

            if( child.material ) {
              // child.material = new THREE.MeshPhongMaterial({
              //   // color: 0xffffff,
              //   vertexColors: THREE.VertexColors
              // });
            }

            } );


          scene.add( object );
          // physics.add.existing(object);

        } );


        let mixers = []
        let action;
        let zombieNo = 0;

        function addZombie(position) {
          const zombie = new THREE.FBXLoader();
          zombie.load( './enemies/FBX/Zombie_Female.fbx', object => {

            object.name = 'zombie' + zombieNo++;

            let mixer = new THREE.AnimationMixer(object);
            action = mixer.clipAction(object.animations[8]);
            mixers.push(mixer);
            action.play();

            object.scale.setScalar(0.01);

            object.position.x = position.x
            object.position.y = position.y;
            object.position.z = position.z;
            object.traverse( function ( child ) {
            });


            const compound = [
              { shape: 'sphere', radius: 0.65, y: 2.5 },
              { shape: 'box', width: 0.5, height: 0.8, depth: 0.2}
            ]
            physics.add.existing(object, {compound});
            object.body.setCollisionFlags(2);

            scene.add( object );

          } );
        }

        addZombie({x: 0, y: 0.5, z: 10});
        addZombie({x: 0, y: 0.5, z: 15});
        addZombie({x: 10, y: 0.5, z: 10});


        // static ground
        const ground = physics.add.ground({ width: 200, height: 200 }, { lambert: { color: 0x815E5B } })
        ground.receiveShadow = true;
        ground.castShadow = true;

        // clock
        const clock = new THREE.Clock()

        // loop
        const animate = () => {

          let delta = clock.getDelta();
          if(mixers) {
            mixers.forEach((mixer) => mixer.update(delta));
          }

          physics.update(clock.getDelta() * 10000)

          physics.updateDebugger()
          renderer.render(scene, camera)


          // Make sure this object exists before accessing it
          requestAnimationFrame(animate)

          for (let i = 0; i < zombieNo; i++ ){
            let zombie = scene.getObjectByName('zombie' + i);
            if (zombie) {
              let rand = Math.random() / 100;

              zombie.position.z += Math.random() / 50;

              zombie.body.needUpdate = true

            }
          }

          renderer.render( scene, camera );

        }
        requestAnimationFrame(animate)
      }
      PhysicsLoader('./lib', () => MainScene())
    </script>
  </body>
</html>
